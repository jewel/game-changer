#!/usr/bin/ruby

# Gems
# (all available in ubuntu via apt)
require 'gtk3'
require 'httparty'

# Standard library
require 'base64'
require 'fileutils'
require 'net/http'
require 'cgi'

Thread.abort_on_exception = true
Thread.report_on_exception = false

class Turbo
  def initialize
    @app = Gtk::Application.new 'com.tuxng.turbo', :flags_none

    @app.signal_connect('activate') { on_activate _1 }

    @app.run
  end

  def inspect
    "#<Turbo>"
  end

  private

  def on_activate app
    @window = Gtk::ApplicationWindow.new app
    @window.set_title 'Game Changer'
    @window.set_default_size 800, 600

    @window.signal_connect 'key-press-event' do |widget, event|
      if event.keyval == Gdk::Keyval::KEY_Escape
        app.quit
      end
    end

    Thread.new do
      fetch_users
    end
    show_spinner
  end

  def switch_contents content
    @window.remove @content if @content
    @content = content
    @window.add @content
    @window.show_all
  end


  def show_spinner
    box = Gtk::Box.new :vertical, 5
    box.set_valign Gtk::Align::CENTER
    spinner = Gtk::Spinner.new
    spinner.set_size_request 64, 64
    spinner.start
    box.add spinner

    switch_contents box
  end

  def show_logins
    # FIXME handle no logins configured
    margin_box = Gtk::Box.new :vertical, 0
    margin_box.set_valign Gtk::Align::CENTER
    margin_box.set_halign Gtk::Align::CENTER

    list_box = Gtk::ListBox.new
    margin_box.add list_box

    # list_box.set_selection_mode Gtk::SelectionMode::NONE
    list_box.set_valign Gtk::Align::CENTER
    list_box.set_halign Gtk::Align::CENTER

    placeholders = []

    @users.each do |user|
      row = Gtk::ListBoxRow.new
      list_box.add row

      button = Gtk::Button.new
      row.add button

      box = Gtk::Box.new :horizontal, 20
      button.add box

      box.add load_icon user, 64, placeholders
      label = Gtk::Label.new user[:name]
      box.add label

      button.signal_connect 'clicked' do
        @user = user
        show_spinner
        Thread.new do
          fetch_games
        end
      end

    end

    Thread.new do
      download_icons placeholders
    end

    switch_contents margin_box
  end

  def bucket_url hash
    "#{server_url}bucket/#{hash[0...2]}/#{hash[0...4]}/#{hash}"
  end

  def server_url
    "http://localhost:4004/"
  end

  def get uri
    res = HTTParty.get "#{server_url}#{uri}", format: :plain
    JSON.parse res.body, symbolize_names: true
  end

  def fetch_bucket hash
    res = HTTParty.get bucket_url hash
    raise "Can't fetch #{hash}" unless res.code == 200
    res.body
  end

  def main_thread method=nil
    GLib::Idle.add do
      if method
        send method
      elsif block_given?
        yield
      else
        raise "Nothing to do"
      end
      false
    end
  end

  def fetch_users
    @users = get "/users"
    main_thread :show_logins
  end

  def fetch_games
    @games = get("/games").select { _1[:default_version] }

    main_thread :show_games
  end

  def download_icons placeholders
    placeholders.each do |(hash, height, widget)|
      picture = fetch_bucket hash
      main_thread do
        loader = GdkPixbuf::PixbufLoader.new
        loader.write picture
        loader.close
        pixbuf = loader.pixbuf

        aspect_ratio = pixbuf.width.to_f / pixbuf.height.to_f
        new_width = (height * aspect_ratio).round
        scaled_pixbuf = pixbuf.scale_simple new_width, height, GdkPixbuf::InterpType::BILINEAR
        widget.add Gtk::Image.new pixbuf: scaled_pixbuf
        widget.show_all
      end
    end
  end

  def load_icon obj, height, placeholders
    hash = obj[:icon] || ""
    if hash == ""
      icon = Gtk::DrawingArea.new
      icon.set_size_request 256, 256
      icon.signal_connect "draw" do |widget, cr|
        # Pick a random color based on the ID
        r = Random.new obj[:id]
        cr.set_source_rgb r.rand, r.rand, r.rand
        cr.rectangle 0, 0, widget.allocated_width, widget.allocated_height
        cr.fill
      end
      return icon
    end

    placeholder = Gtk::Box.new :vertical, 0
    placeholders.push [hash, height, placeholder]
    return placeholder
  end

  def show_games
    # FIXME handle no games to show
    grid = Gtk::FlowBox.new
    grid.set_valign Gtk::Align::CENTER
    grid.set_halign Gtk::Align::CENTER
    placeholders = []
    @games.each do |game|
      button = Gtk::Button.new
      grid.add button
      box = Gtk::Box.new :vertical, 20
      button.add box

      button.signal_connect 'clicked' do
        spawn_game game
      end

      box.add load_icon game, 256, placeholders

      label = Gtk::Label.new game[:name]
      box.add label
    end

    download_icons placeholders

    switch_contents grid
  end

  def game_path version
    storage_path(version) + "game"
  end

  def storage_path version
    Pathname.new "/tmp/game-changer/#{version[:id]}"
  end

  def download_game game
    version = game[:default_version]
    # Load more data
    version = get "/versions/#{version[:id]}"

    # FIXME we should first count all the files we already have, and
    # queue up those we need, so that we can give them a progress bar of just
    # what we intend to download.
    downloaded = 0

    basedir = game_path version
    uri = URI server_url
    Net::HTTP.start uri.host, uri.port do |http|
      version[:bucket].each do |(path, hash, size, mtime, executable)|
        dest = "#{basedir}/#{path}"
        mtime = Time.at mtime

        if File.exist? dest
          stat = File.stat dest
          if (stat.mtime - mtime).abs <= 0.1 && stat.size == size
            puts "correct: #{path}"
            next
          end
          puts "incorrect: #{path}"
          File.unlink dest
        end

        puts "downloading: #{path}"

        url = bucket_url hash
        req = Net::HTTP::Get.new url
        http.request req do |res|
          if res.code != "200"
            raise "HTTP Failure code: #{res.code}"
          end
          FileUtils.mkdir_p File.dirname dest
          File.open dest, 'wb' do |io|
            last_update = Time.new
            res.read_body do |chunk|
              io.write chunk
              downloaded += chunk.size
              if Time.new - last_update > 1.0 / 30
                update_status "Downloading #{game[:name]} #{(downloaded.to_f/version[:size]*100).round(1)}%"
                last_update = Time.new
              end
            end
          end
        end
        File.utime mtime, mtime, dest
        mode = 0666
        mode |= 0111 if executable
        File.chmod mode, dest

        stat = File.stat dest
        unless (stat.mtime - mtime).abs <= 0.1 && stat.size == size
          raise "Was not able to save #{dest} properly"
        end
      end
    end

    # Cleanup any extra cruft from a previous run
    # FIXME We could check for a previous run's save games first before wiping
    # them here
    allowed_paths = Set.new
    version[:bucket].each do |(path, hash, size, mtime, executable)|
      allowed_paths.add path
    end

    # Clean out everything else besides the game path
    storage_path(version).find do |file|
      next unless file.file?
      if file.to_s.start_with? "#{basedir}/"
        path = file.relative_path_from basedir
        next if allowed_paths.member? path.to_s
        puts "remove game: #{file}"
      else
        puts "remove other: #{file}"
      end

      file.unlink
    end

    update_status "Finding saved games"
    save = get "/saves/latest/#{@user[:id]}/#{game[:id]}"
    if save
      download_save save, game, version
    end
    launch_game game, version
  end

  def download_save save, game, version
    uri = URI server_url
    Net::HTTP.start uri.host, uri.port do |http|
      req = Net::HTTP::Get.new "/saves/#{@user[:id]}/#{game[:id]}/#{save[:id]}"
      http.request req do |res|
        if res.code != "200"
          raise "HTTP Failure code: #{res.code}"
        end
        # FIXME use the Content-Length to give the user progress updates
        buffer = String.new
        path_length = nil
        path = nil
        file = nil
        size = nil
        written = nil
        res.read_body do |chunk|
          puts "Chunk:  #{chunk.inspect}"
          buffer << chunk
          loop do
            break if buffer.empty?
            if !path_length
              if buffer =~ /\A(.*\n)/
                path_length = $1.to_i
                buffer = buffer[$1.bytesize..]
              else
                break
              end
            end
            if path_length && !path
              if buffer.size >= path_length
                path = buffer[0...path_length]
                puts "path is #{path.inspect}"
                file = File.open "#{storage_path version}/#{path}", 'wb'
                written = 0
                buffer = buffer[path_length..]
              else
                break
              end
            end
            if path && !size
              if buffer =~ /\A(.*\n)/
                size = $1.to_i
                puts "size is #$1"
                buffer = buffer[($1.bytesize)..]
              else
                break
              end
            end
            if file
              remaining = size - written
              puts "need #{remaining}"
              written += file.write buffer[0...remaining]
              puts "written #{written}"
              buffer = buffer[remaining..]
              if written == size
                file.close
                path_length = nil
                file = nil
                path = nil
                size = nil
                written = nil
              end
            end
          end
        end
      end
    end
  end

  def launch_game game, version
    # FIXME use a PTY here to capture stdout and stderr
    if version[:command] && version[:command] != ""
      command = version[:command]
    else
      raise "No command"
    end

    # TODO use pgroup so we can watch all children
    # TODO build full environment
    env = clean_environment version
    pid = Process.spawn env, "#{command}", chdir: game_path(version).to_s, unsetenv_others: true
    update_status "Running #{game[:name]}"
    main_thread do
      @spinner.hide
    end
    Process.wait pid
    update_status "Uploading saved games from #{game[:name]}"
    upload_saves game, version
    main_thread :show_games
  end

  def upload_saves game, version
    game_files = {}
    version[:content].each do |file|
      game_files[file[:path]] = file
    end

    basedir = game_path(version)

    files = []
    total_size = 0

    storage_path(version).find do |file|
      next unless file.file?
      if file.to_s.start_with? "#{basedir}/"
        path = file.relative_path_from basedir
        # ignore game files unless they have changed
        if old = game_files[path.to_s]
          mtime = Time.at old[:mtime]
          stat = file.stat
          next if (stat.mtime - mtime).abs <= 0.1 && stat.size == old[:size]
          puts "game file changed: #{path}"
        end
      end
      path = file.relative_path_from storage_path(version)
      puts "backing up: #{path}"
      total_size += file.size
      files.push file
    end

    # FIXME, we really only need to upload new saved games files, not all the
    # historical saved games, every time.  Finding a way to do so will let us
    # speed the upload and save disk space.
    puts "Saved games are #{files.size} files, #{(total_size.to_f / 1024 / 1024).round(1)} MB"
    uri = URI server_url
    Net::HTTP.start uri.host, uri.port do |http|
      req = Net::HTTP::Put.new "/saves/#{@user[:id]}/#{version[:id]}"
      req.add_field 'Transfer-Encoding', 'chunked'
      req.add_field 'Content-Type', 'application/octet-stream'
      req.add_field 'Accept', 'application/json'

      # We have to invert control, letting the Net::HTTP call into our fake IO
      # object when it needs more data
      io = Class.new do
        def read size=4096, outbuf=nil
          raise "Need a next_chunk block" unless @next_chunk
          chunk = @next_chunk.call size
          if chunk && outbuf
            outbuf.clear
            outbuf << chunk
          end
          # next_chunk is allowed to return "" which means it's time to retry
          return read(size, outbuf) if chunk && chunk.size == 0
          chunk
        end

        def next_chunk &block
          @next_chunk = block
        end

        def close
        end
      end.new

      # Can't get msgpack streaming to work with Net::HTTP streaming, so we'll
      # make our own little protocol.  This essentially double-chunks the
      # stream, which is fine.
      file = nil
      handle = nil

      length = nil
      target = nil

      io.next_chunk do |size|
        if !file
          file = files.shift
          if file
            path = file.relative_path_from(storage_path(version))
            s = String.new
            s << path.to_s.bytesize.to_s
            s << "\n"
            s << path.to_s
            s
          else
            nil # signal EOF
          end
        elsif !handle
          handle = file.open 'rb'
          s = String.new
          target = handle.size
          length = 0
          s << target.to_s
          s << "\n"
          s
        else
          chunk = handle.read size
          if !chunk
            if target != length
              raise "File size changed during reading"
            end
            handle = nil
            file = nil
            length = nil
            target = nil
            redo
          else
            length += chunk.bytesize
            chunk
          end
        end
      end
      req.body_stream = io
      res = http.request req
      # TODO error handling here
      puts "Server said #{res.body}"
    end
  end

  def update_status message
    puts message
    main_thread do
      @status&.set_text message
    end
  end

  def spawn_game game
    box = Gtk::Box.new :vertical, 5
    box.set_valign Gtk::Align::CENTER
    spinner = Gtk::Spinner.new
    spinner.set_size_request 64, 64
    spinner.start
    box.add spinner
    label = Gtk::Label.new "Downloading #{game[:name]}"
    box.add label

    @status = label
    @spinner = spinner

    switch_contents box
    Thread.new do
      download_game game
    end
  end

  def clean_environment version
    {
      'SHELL' => "/bin/bash",
      'PWD' => game_path(version).to_s,
      'LANG' => ENV['LANG'],
      'DISPLAY' => ENV['DISPLAY'],
      'XAUTHORITY' => ENV['XAUTHORITY'],
      'HOME' => storage_path(version).to_s,
      'USER' => "ggttyl",
      'USERNAME' => "ggttyl",
      'PATH' => "#{game_path(version)}:#{ENV['PATH']}",
    }
  end
end

Turbo.new
