#!/usr/bin/ruby

# Gems
require 'gtk3'
require 'httparty'

# Standard library
require 'base64'
require 'fileutils'
require 'net/http'
require 'cgi'

Thread.abort_on_exception = true
Thread.report_on_exception = false

class Turbo
  def initialize
    @app = Gtk::Application.new 'com.tuxng.turbo', :flags_none

    @app.signal_connect('activate') { on_activate _1 }

    @app.run
  end

  def inspect
    "#<Turbo>"
  end

  private

  def on_activate app
    @window = Gtk::ApplicationWindow.new app
    @window.set_title 'Game Changer'
    @window.set_default_size 800, 600

    @window.signal_connect 'key-press-event' do |widget, event|
      if event.keyval == Gdk::Keyval::KEY_Escape
        app.quit
      end
    end

    Thread.new do
      fetch_users
    end
    show_spinner
  end

  def switch_contents content
    @window.remove @content if @content
    @content = content
    @window.add @content
    @window.show_all
  end


  def show_spinner
    box = Gtk::Box.new :vertical, 5
    box.set_valign Gtk::Align::CENTER
    spinner = Gtk::Spinner.new
    spinner.set_size_request 64, 64
    spinner.start
    box.add spinner

    switch_contents box
  end

  def show_logins
    margin_box = Gtk::Box.new :vertical, 0
    margin_box.set_valign Gtk::Align::CENTER
    margin_box.set_halign Gtk::Align::CENTER

    list_box = Gtk::ListBox.new
    margin_box.add list_box

    # list_box.set_selection_mode Gtk::SelectionMode::NONE
    list_box.set_valign Gtk::Align::CENTER
    list_box.set_halign Gtk::Align::CENTER

    @users.each do |user|
      row = Gtk::ListBoxRow.new
      list_box.add row

      button = Gtk::Button.new
      row.add button

      box = Gtk::Box.new :horizontal, 20
      button.add box

      box.add load_icon user, 64
      label = Gtk::Label.new user[:name]
      box.add label

      button.signal_connect 'clicked' do
        show_spinner
        Thread.new do
          fetch_games
        end
      end

    end

    switch_contents margin_box
  end

  def server_url
    "http://localhost:4004/"
  end

  def get uri
    res = HTTParty.get "#{server_url}#{uri}", format: :plain
    JSON.parse res, symbolize_names: true
  end

  def main_thread method=nil
    GLib::Idle.add do
      if method
        send method
      elsif block_given?
        yield
      else
        raise "Nothing to do"
      end
      false
    end
  end

  def fetch_users
    @users = get "/users"
    main_thread :show_logins
  end

  def fetch_games
    @games = get("/games").select { _1[:default_version] }

    main_thread :show_games
  end

  def load_icon obj, height
    if obj[:icon] && obj[:icon] != ""
      icon = Base64.decode64 obj[:icon]
      loader = GdkPixbuf::PixbufLoader.new
      loader.write icon
      loader.close
      pixbuf = loader.pixbuf

      aspect_ratio = pixbuf.width.to_f / pixbuf.height.to_f
      new_width = (height * aspect_ratio).round
      scaled_pixbuf = pixbuf.scale_simple new_width, height, GdkPixbuf::InterpType::BILINEAR
      icon = Gtk::Image.new pixbuf: scaled_pixbuf
    else
      icon = Gtk::DrawingArea.new
      icon.set_size_request 256, 256
      icon.signal_connect "draw" do |widget, cr|
        # Pick a random color based on the ID
        r = Random.new obj[:id]
        cr.set_source_rgb r.rand, r.rand, r.rand
        cr.rectangle 0, 0, widget.allocated_width, widget.allocated_height
        cr.fill
      end
    end
    icon
  end

  def show_games
    grid = Gtk::FlowBox.new
    grid.set_valign Gtk::Align::CENTER
    grid.set_halign Gtk::Align::CENTER
    @games.each do |game|
      button = Gtk::Button.new
      grid.add button
      box = Gtk::Box.new :vertical, 20
      button.add box

      button.signal_connect 'clicked' do
        spawn_game game
      end

      box.add load_icon game, 256

      label = Gtk::Label.new game[:name]
      box.add label
    end

    switch_contents grid
  end

  def game_path version
    "#{storage_path version}/game"
  end

  def storage_path version
    "/tmp/game-changer/#{version[:id]}"
  end

  def download_game game
    version = game[:default_version]
    # Load more data
    version = get "/versions/#{version[:id]}"

    # FIXME we should first count all the files we already have, and
    # queue up those we need, so that we can give them a progress bar of just
    # what we intend to download.
    downloaded = 0

    basedir = game_path version
    uri = URI server_url
    Net::HTTP.start uri.host, uri.port do |http|
      version[:content].each do |file|
        dest = "#{basedir}/#{file[:path]}"
        mtime = Time.at file[:mtime]

        if File.exist? dest
          stat = File.stat dest
          if (stat.mtime - mtime).abs <= 0.1 && stat.size == file[:size]
            puts "correct: #{file[:path]}"
            next
          end
          puts "incorrect: #{file[:path]}"
          File.unlink dest
        end

        puts "downloading: #{file[:path]}"

        url = "#{version[:storage_url]}/#{CGI.escape file[:path]}"
        url.gsub! "%2F", "/"
        url.gsub! "+", "%20"

        req = Net::HTTP::Get.new url
        http.request req do |res|
          if res.code != "200"
            raise "HTTP Failure code: #{res.code}"
          end
          FileUtils.mkdir_p File.dirname dest
          File.open dest, 'wb' do |io|
            last_update = Time.new
            res.read_body do |chunk|
              io.write chunk
              downloaded += chunk.size
              if Time.new - last_update > 1.0 / 30
                update_status "Downloading #{game[:name]} #{(downloaded.to_f/version[:size]*100).round(1)}%"
                last_update = Time.new
              end
            end
          end
        end
        File.utime mtime, mtime, dest
        mode = 0444
        mode |= 0111 if file[:executable]
        mode |= 0200 if file[:writable]
        File.chmod mode, dest

        stat = File.stat dest
        unless (stat.mtime - mtime).abs <= 0.1 && stat.size == file[:size]
          raise "Was not able to save #{dest} properly"
        end
      end
    end

    # Cleanup any extra cruft from a previous run
    # FIXME We could check for a previous run's save games first before wiping
    # them here
    allowed_paths = Set.new
    version[:content].each do |file|
      allowed_paths.add file[:path]
    end

    Dir.glob "**/*", File::FNM_DOTMATCH, base: basedir do |path|
      fullpath = "#{basedir}/#{path}"
      next if File.directory? fullpath
      next if allowed_paths.member? path
      puts "remove: #{path}"
      # TODO add removal code here.
    end

    # Clean out everything else besides the game path
    Dir.glob "**/*", File::FNM_DOTMATCH, base: storage_path(version) do |path|
      file = Pathname.new "#{storage_path(version)}/#{path}"
      next if file.directory?
      p file.to_s
      next if file.to_s.start_with? "#{basedir}/"
      puts "remove other: #{path}"
    end
    exit

    launch_game game, version
  end

  def launch_game game, version
    # FIXME use a PTY here to capture stdout and stderr
    if version[:command] && version[:command] != ""
      command = version[:command]
    else
      # Guess at which file we should run, hopefully there's just one
      command = version[:content].sort_by { _1[:path] }.select { _1[:executable] }.first[:path]
    end

    # TODO use pgroup so we can watch all children
    # TODO build full environment
    env = clean_environment version
    pid = Process.spawn env, "./#{command}", chdir: game_path(version), unsetenv_others: true
    update_status "Running #{game[:name]}"
    main_thread do
      @spinner.hide
    end
    Process.wait pid
    main_thread :show_games
  end

  def update_status message
    main_thread do
      @status&.set_text message
    end
  end

  def spawn_game game
    box = Gtk::Box.new :vertical, 5
    box.set_valign Gtk::Align::CENTER
    spinner = Gtk::Spinner.new
    spinner.set_size_request 64, 64
    spinner.start
    box.add spinner
    label = Gtk::Label.new "Downloading #{game[:name]}"
    box.add label

    @status = label
    @spinner = spinner

    switch_contents box
    Thread.new do
      download_game game
    end
  end

  def clean_environment version
    basedir = storage_path version
    {
      'SHELL' => "/bin/bash",
      'PWD' => basedir,
      'LANG' => ENV['LANG'],
      'DISPLAY' => ENV['DISPLAY'],
      'XAUTHORITY' => ENV['XAUTHORITY'],
      'HOME' => basedir,
      'USER' => "ggttyl",
      'USERNAME' => "ggttyl",
    }
  end
end

Turbo.new
