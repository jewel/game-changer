#!/usr/bin/ruby

# Gems
# (all available in ubuntu via apt)
require 'gtk3'
require 'httparty'

# Standard library
require 'base64'
require 'fileutils'
require 'net/http'
require 'cgi'

Thread.abort_on_exception = true
Thread.report_on_exception = false

class Turbo
  def initialize
    @app = Gtk::Application.new 'com.tuxng.turbo', :flags_none

    @app.signal_connect('activate') { on_activate _1 }

    @app.run
  end

  def inspect
    "#<Turbo>"
  end

  private

  def on_activate app
    @window = Gtk::ApplicationWindow.new app
    @window.set_title 'Game Changer'
    @window.set_default_size 800, 600

    @window.signal_connect 'key-press-event' do |widget, event|
      if event.keyval == Gdk::Keyval::KEY_Escape
        app.quit
      end
    end

    Thread.new do
      fetch_users
    end
    show_spinner
  end

  def switch_contents content
    @window.remove @content if @content
    @content = content
    @window.add @content
    @window.show_all
  end


  def show_spinner
    box = Gtk::Box.new :vertical, 5
    box.set_valign Gtk::Align::CENTER
    spinner = Gtk::Spinner.new
    spinner.set_size_request 64, 64
    spinner.start
    box.add spinner

    switch_contents box
  end

  def show_logins
    # FIXME handle no logins configured
    margin_box = Gtk::Box.new :vertical, 0
    margin_box.set_valign Gtk::Align::CENTER
    margin_box.set_halign Gtk::Align::CENTER

    list_box = Gtk::ListBox.new
    margin_box.add list_box

    # list_box.set_selection_mode Gtk::SelectionMode::NONE
    list_box.set_valign Gtk::Align::CENTER
    list_box.set_halign Gtk::Align::CENTER

    placeholders = []

    @users.each do |user|
      row = Gtk::ListBoxRow.new
      list_box.add row

      button = Gtk::Button.new
      row.add button

      box = Gtk::Box.new :horizontal, 20
      button.add box

      box.add load_icon user, 64, placeholders
      label = Gtk::Label.new user[:name]
      box.add label

      button.signal_connect 'clicked' do
        @user = user
        show_spinner
        Thread.new do
          fetch_games
        end
      end

    end

    Thread.new do
      download_icons placeholders
    end

    switch_contents margin_box
  end

  def bucket_url hash
    "#{server_url}bucket/#{hash[0...2]}/#{hash[0...4]}/#{hash}"
  end

  def server_url
    "http://localhost:4004/"
  end

  def get uri
    res = HTTParty.get "#{server_url}#{uri}", format: :plain
    JSON.parse res.body, symbolize_names: true
  end

  def fetch_bucket hash
    res = HTTParty.get bucket_url hash
    raise "Can't fetch #{hash}" unless res.code == 200
    res.body
  end

  def main_thread method=nil
    GLib::Idle.add do
      if method
        send method
      elsif block_given?
        yield
      else
        raise "Nothing to do"
      end
      false
    end
  end

  def fetch_users
    @users = get "/users"
    main_thread :show_logins
  end

  def fetch_games
    @games = get("/games").select { _1[:default_version] }

    main_thread :show_games
  end

  def download_icons placeholders
    placeholders.each do |(hash, height, widget)|
      picture = fetch_bucket hash
      main_thread do
        loader = GdkPixbuf::PixbufLoader.new
        loader.write picture
        loader.close
        pixbuf = loader.pixbuf

        aspect_ratio = pixbuf.width.to_f / pixbuf.height.to_f
        new_width = (height * aspect_ratio).round
        scaled_pixbuf = pixbuf.scale_simple new_width, height, GdkPixbuf::InterpType::BILINEAR
        widget.add Gtk::Image.new pixbuf: scaled_pixbuf
        widget.show_all
      end
    end
  end

  def load_icon obj, height, placeholders
    hash = obj[:icon] || ""
    if hash == ""
      icon = Gtk::DrawingArea.new
      icon.set_size_request 256, 256
      icon.signal_connect "draw" do |widget, cr|
        # Pick a random color based on the ID
        r = Random.new obj[:id]
        cr.set_source_rgb r.rand, r.rand, r.rand
        cr.rectangle 0, 0, widget.allocated_width, widget.allocated_height
        cr.fill
      end
      return icon
    end

    placeholder = Gtk::Box.new :vertical, 0
    placeholders.push [hash, height, placeholder]
    return placeholder
  end

  def show_games
    # FIXME handle no games to show
    grid = Gtk::FlowBox.new
    grid.set_valign Gtk::Align::CENTER
    grid.set_halign Gtk::Align::CENTER
    placeholders = []
    @games.each do |game|
      button = Gtk::Button.new
      grid.add button
      box = Gtk::Box.new :vertical, 20
      button.add box

      button.signal_connect 'clicked' do
        spawn_game game
      end

      box.add load_icon game, 256, placeholders

      label = Gtk::Label.new game[:name]
      box.add label
    end

    download_icons placeholders

    switch_contents grid
  end

  def game_path version
    storage_path(version) + "game"
  end

  def storage_path version
    Pathname.new "/tmp/game-changer/#{version[:id]}"
  end

  def download_game game
    version = game[:default_version]
    # Load more data
    version = get "/versions/#{version[:id]}"

    bucket = version[:bucket]
    bucket.each do |file|
      file.dup.merge({path: "game/#{file[:path]}"})
    end

    save = get "/saves/latest?user_id=#{@user[:id]}&game_id=#{game[:id]}"

    # Saved files may overlap game files (e.g. if a preferences file is updated)
    if save
      bucket = bucket + save[:bucket]
      pp bucket.map { _1[:path] }
      # remove duplicates, last one wins
      paths = Set.new
      bucket.reverse!
      bucket.select! do |file|
        present = paths.member? file[:path]
        paths.add file[:path]
        !present
      end
      bucket.reverse!
      pp bucket.map { _1[:path] }
    end

    # FIXME we should first count all the files we already have, and
    # queue up those we need, so that we can give them a progress bar of just
    # what we intend to download.
    downloaded = 0

    basedir = storage_path version
    uri = URI server_url
    Net::HTTP.start uri.host, uri.port do |http|
      version[:bucket].each do |file|
        path = file[:path]
        dest = "#{basedir}/#{path}"
        mtime = Time.at file[:mtime]

        if File.exist? dest
          stat = File.stat dest
          if (stat.mtime - mtime).abs <= 0.1 && stat.size == file[:size]
            puts "correct: #{path}"
            next
          end
          puts "incorrect: #{path}"
          File.unlink dest
        end

        url = bucket_url file[:hash]
        puts "downloading: #{path}"

        req = Net::HTTP::Get.new url
        http.request req do |res|
          if res.code != "200"
            raise "HTTP Failure code: #{res.code}"
          end
          FileUtils.mkdir_p File.dirname dest
          File.open dest, 'wb' do |io|
            last_update = Time.new
            res.read_body do |chunk|
              io.write chunk
              downloaded += chunk.size
              if Time.new - last_update > 1.0 / 30
                update_status "Downloading #{game[:name]} #{(downloaded.to_f/version[:size]*100).round(1)}%"
                last_update = Time.new
              end
            end
          end
        end
        File.utime mtime, mtime, dest
        mode = 0666
        mode |= 0111 if file[:executable]
        File.chmod mode, dest

        stat = File.stat dest
        unless (stat.mtime - mtime).abs <= 0.1 && stat.size == file[:size]
          raise "Was not able to save #{dest} properly"
        end
      end
    end

    # Cleanup any extra cruft from a previous run
    # FIXME We could check for a previous run's save games first before wiping
    # them here
    allowed_paths = Set.new
    bucket.each do |file|
      allowed_paths.add file[:path]
    end

    # Clean out everything else besides the game path
    storage_path(version).find do |file|
      next unless file.file?
      path = file.relative_path_from basedir
      next if allowed_paths.member? path.to_s
      puts "remove: #{path}"

      file.unlink
    end

    launch_game game, version, save
  end

  def launch_game game, version, old_save
    # FIXME use a PTY here to capture stdout and stderr
    if version[:command] && version[:command] != ""
      command = version[:command]
    else
      raise "No command"
    end

    # TODO use pgroup so we can watch all children
    # TODO build full environment
    env = clean_environment version
    pid = Process.spawn env, "#{command}", chdir: game_path(version).to_s, unsetenv_others: true
    update_status "Running #{game[:name]}"
    main_thread do
      @spinner.hide
    end
    Process.wait pid
    update_status "Uploading saved games from #{game[:name]}"
    upload_save game, version, old_save
    main_thread :show_games
  end

  def upload_save game, version, old_save
    game_files = {}
    version[:bucket].each do |file|
      game_files[file[:path]] = file
    end

    basedir = game_path(version)

    files = []
    total_size = 0

    old_save_by_path = {}
    if old_save
      old_save[:bucket].each do |file|
        old_save_by_path[file[:path]] = file
      end
    end

    uri = URI server_url
    Net::HTTP.start uri.host, uri.port do |http|
      save_bucket = []
      storage_path(version).find do |file|
        next unless file.file?
        if file.to_s.start_with? "#{basedir}/"
          path = file.relative_path_from basedir
          # ignore game files unless they have changed
          if old = game_files[path.to_s]
            mtime = Time.at old[:mtime]
            stat = file.stat
            next if (stat.mtime - mtime).abs <= 0.1 && stat.size == old[:size]
            puts "game file changed: #{path}"
          end
        end

        path = file.relative_path_from storage_path(version)
        # Now check if file hasn't changed from the last save, if it hasn't
        # then we don't need to upload it again, but we still need to include
        # it in the backup
        hash = nil
        if old = old_save_by_path[path.to_s]
          mtime = Time.at old[:mtime]
          stat = file.stat
          if (stat.mtime - mtime).abs <= 0.1 && stat.size == old[:size]
            hash = old[:hash]
            puts "old save file not changed: #{path}"
          else
            puts "old save file changed: #{path}"
          end
        end

        if !hash
          puts "uploading: #{path}"
          req = Net::HTTP::Post.new "/bucket_files"
          form_data = [['file', file.open('rb')]]
          req.set_form form_data, 'multipart/form-data'
          res = http.request req
          if res.code != "200"
            pp res
            raise "Could not upload, error #{res.code}: #{path}"
          end
          obj = JSON.parse res.body, symbolize_names: true
          hash = obj[:hash]
          raise "Missing hash" unless hash
        end

        save_bucket.push({
          path: path,
          hash: hash,
          size: file.size,
          mtime: file.mtime.to_f,
          executable: file.stat.executable?,
        })
      end

      req = Net::HTTP::Post.new "/saves?user_id=#{@user[:id]}&version_id=#{version[:id]}"
      req.add_field "Content-Type", "application/json"
      req.body = save_bucket.to_json
      res = http.request req
      if res.code != "200"
        pp res
        raise "Could not upload bucket, error #{res.code}"
      end
    end
  end

  def update_status message
    puts message
    main_thread do
      @status&.set_text message
    end
  end

  def spawn_game game
    box = Gtk::Box.new :vertical, 5
    box.set_valign Gtk::Align::CENTER
    spinner = Gtk::Spinner.new
    spinner.set_size_request 64, 64
    spinner.start
    box.add spinner
    label = Gtk::Label.new "Downloading #{game[:name]}"
    box.add label

    @status = label
    @spinner = spinner

    switch_contents box
    Thread.new do
      download_game game
    end
  end

  def clean_environment version
    {
      'SHELL' => "/bin/bash",
      'PWD' => game_path(version).to_s,
      'LANG' => ENV['LANG'],
      'DISPLAY' => ENV['DISPLAY'],
      'XAUTHORITY' => ENV['XAUTHORITY'],
      'HOME' => storage_path(version).to_s,
      'USER' => "ggttyl",
      'USERNAME' => "ggttyl",
      'PATH' => "#{game_path(version)}:#{ENV['PATH']}",
    }
  end
end

Turbo.new
